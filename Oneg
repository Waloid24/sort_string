#include <stdio.h>
#include <stdlib.h>
#include<sys/stat.h>
#include <ctype.h>
#include <cstring>

int reading_file (char ** buf_elements_1, FILE ** file_output_1, const char * arg_console_1, const char * arg_console_2);
int correct_buf (char * buf_elements, int n_elements);
//void arr_strings (char ** mass, char * buf, int n_elem_1);
void print_array_in_file (char ** array_strings_for_sort, int n_string, FILE * file_output);
void swap (const void * str1, const void * str2);
int alphabetcomp (const void * str1, const void * str2);
int numcomp (const void * n1, const void * n2);
//int my_strcmp (const char * string1, const char * string2);
void filling_struct (struct str_ing * mass_1, char * buf, int n_elem_1);
void print_array_in_file (struct str_ing * ptr_1, int n_string, FILE * file_output);
int sort_from_end (const void * srt1, const void * str2);

struct str_ing {
	char * p = nullptr;
	int length_str = 0;
};

int main (int argc, char * argv[])
{
	FILE * file_output = nullptr;
	char * buf_elements = nullptr;
	int n_elem = reading_file (&buf_elements, &file_output, argv[1], argv[2]);
	
	printf("after reading_file ptr buf_elements = %p\n", buf_elements);
	printf("after reading_file ptr file_output = %p\n", file_output);
	printf("after reading_file ptr buf_elements = %p\n", buf_elements);
	printf("buf_elements[0] = %c\n", buf_elements[0]);
	
	int n_strings = correct_buf (buf_elements, n_elem);
	
	struct str_ing * array = (struct str_ing *)calloc (n_strings, sizeof(struct str_ing));
	
	struct str_ing * ptr = array;
	
	printf("after correct_buf n_strings = %d\n", n_strings);
	
	//char ** arr_ptr_strings = (char **) calloc(n_strings, sizeof (char *));
	//arr_strings (arr_ptr_strings, buf_elements, n_elem);
	
	filling_struct (ptr, buf_elements, n_elem);
	printf ("Frolov\n");
	//qsort (arr_ptr_strings, n_strings, sizeof(char *), alphabetcomp);
	printf ("HERE %p\n", ptr);
	
	qsort (array, n_strings, sizeof(struct str_ing), alphabetcomp);
	printf("lollol\n");
	print_array_in_file (ptr, n_strings, file_output);
	
	FILE * output_sort_end = fopen (argv[1], "ab+");
	qsort (array, n_strings, sizeof(struct str_ing), sort_from_end);
	print_array_in_file (ptr, n_strings, output_sort_end);	
	
	return 0;
}
 
void filling_struct (struct str_ing * mass_1, char * buf, int n_elem_1)
{
	mass_1[0].p = buf;
	printf("mass_1[0].p = buf + 1 = %s\n", mass_1[0].p);
	for (int num_sym = 0, j = 0; num_sym < n_elem_1 && *buf != EOF; num_sym++)
	{
		(mass_1[j].length_str)++;
		if (*buf == '\0')
		{
			mass_1[j+1].p = buf + 1;
			//(mass_1[j].length_str)++;
			printf("mass_1[%d+1].p = buf + 1 = %s\n", j, mass_1[j+1].p);
			printf("mass_1[%d].length_str = %d\n", j, mass_1[j].length_str); //длина строки
			j++;
		}
		buf++;
	}
}

int sort_from_end (const void * str1, const void * str2)
{
	char * p1 = ((struct str_ing *)str1)->p;
	int length_1 = ((struct str_ing *)str1)->length_str;
	char * p2 = ((struct str_ing *)str2)->p;
	int length_2 = ((struct str_ing *)str2)->length_str;
	
//	char * p1_end = p1 + length_1 - 1;
//	char * p2_end = p2 + length_2 - 1;
	
	for (int x_1 = length_1, x_2 = length_2; x_1 > 0 && x_2 > 0; x_1--, x_2--)
	{
		if (!isalpha(p1[x_1-1]))
			x_1--;
		if (!isalpha(p2[x_2-1]))
			x_2--;
		if      ((p1[x_1-1] > p2[x_2-1]) && isalpha(p1[x_1-1]) && isalpha(p2[x_2-1]))
			return 1;
		else if ((p1[x_1-1] < p2[x_2-1]) && isalpha(p1[x_1-1]) && isalpha(p2[x_2-1]))
			return -1;
		else 
			continue;
	}
	return 0;	
}
 
int reading_file (char ** buf_elements_1, FILE ** file_output_1, const char * arg_console_1, const char * arg_console_2)
{
	struct stat file_info;
	FILE * file_input = fopen (arg_console_1, "rb");
	if (file_input == NULL)
	{
		fprintf(stderr, "Error: unable to open argv file[1]\n");
		return -1;
	}
	
	*file_output_1 = fopen (arg_console_2, "wb");
	if (file_output_1 == NULL)
	{
		fprintf(stderr, "Error: unable to open argv file[2]\n");
		return -2;
	}
	
	stat (arg_console_1, &file_info);
	int n_elem = file_info.st_size;
	printf("n_elem = %d\n", n_elem);
	
	*buf_elements_1 = (char *) calloc (n_elem + 1, sizeof(char));
	if (*buf_elements_1 == NULL)
	{
		fprintf (stderr, "Error in allocating memory for saving.\n");
		return -2;
	}	
	(*buf_elements_1)[n_elem] = '\0';
	
	fread (*buf_elements_1, 1, n_elem, file_input);
	
	return n_elem;
}

int correct_buf (char * buf_elements_2, int n_elements)
{
	int n_strings = 0;
	
	printf("buf_elements_2 = %p\n", buf_elements_2);
	
	for (int i = 0; i < n_elements; i++)
	{
//		if (buf_elements_2[i] == '\r')
//			buf_elements_2[i] = '\0';
		if (buf_elements_2[i] == '\n')
		{
			//printf ("buf_elements_2[i] = %d\n", &(buf_elements_2[i]) - buf_elements_2);
			buf_elements_2[i] = '\0';
			n_strings++;
		}
	}
	return n_strings+1;
}

int alphabetcomp (const void * str1, const void * str2)
{
//	printf("comp\n");
	return strcmp ((((struct str_ing *)str1)->p), ((struct str_ing *)str2)->p);	
}

//int numcomp (const void * n1, const void * n2)
//{
//	if (*((int *)n1) > *((int *) n2))
//		return 1;
//	else if (*((int *)n1) < *((int *) n2))
//		return -1;
//	return 0;
//}

void swap (const void * str1, const void * str2)
{
	const void * temp = nullptr;
	temp = str1; 
	str1 = str2;
	str2 = temp;
}

void print_array_in_file (struct str_ing * ptr_1, int n_string, FILE * file_output)
{
	printf("lol\n");
	for (int i = 0; i < n_string; i++)
	{
		printf("ptr_1[%d].p = %s\n", i, ptr_1[i].p);
		fputs(ptr_1[i].p, file_output);
	}
}

int my_strcmp (const char * string1, const char * string2)
{
	for (int i = 0, j = 0; string1[i] != '\0' && string2[j] != '\0'; i++, j++)
	{
		if (!isalpha(string1[i]))
			i++;
		if (!isalpha(string2[j]))
			j++;
		if ((string1[i] > string2[j]) && isalpha(string1[i]) && isalpha(string2[j]))
			return 1;
		else if ((string1[i] < string2[j]) && isalpha(string1[i]) && isalpha(string2[j]))
			return -1;
		else 
			continue;
	}
	return 0;
}
