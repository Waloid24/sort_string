#include <stdio.h>
#include <stdlib.h>
#include<sys/stat.h>
#include <ctype.h>

int reading_file (char ** buf_elements_1, FILE ** file_output_1, const char * arg_console_1, const char * arg_console_2);
int correct_buf (char * buf_elements, int n_elements);
//void arr_strings (char ** mass, char * buf, int n_elem_1);
void print_array_in_file (char ** array_strings_for_sort, int n_string, FILE * file_output);
void swap (const void * str1, const void * str2);
int alphabetcomp (const void * str1, const void * str2);
int numcomp (const void * n1, const void * n2);
//int my_strcmp (const char * string1, const char * string2);
void filling_struct (struct str_ing * mass_1, char * buf, int n_elem_1);
void print_array_in_file (struct str_ing * ptr_1, int n_string, FILE * file_output);

struct str_ing {
	char * p = nullptr;
	int lenght_str = 0;
};

int main (int argc, char * argv[])
{
	FILE * file_output = nullptr;
	char * buf_elements = nullptr;
	int n_elem = reading_file (&buf_elements, &file_output, argv[1], argv[2]);
	
	printf("after reading_file ptr buf_elements = %p\n", buf_elements);
	printf("after reading_file ptr file_output = %p\n", file_output);
	printf("after reading_file ptr buf_elements = %p\n", buf_elements);
	printf("buf_elements[0] = %c\n", buf_elements[0]);
	
	int n_strings = correct_buf (buf_elements, n_elem);
	
	struct str_ing array[n_strings] = {};
	struct str_ing * ptr = array;
	
	printf("after correct_buf n_strings = %d\n", n_strings);
	
	//char ** arr_ptr_strings = (char **) calloc(n_strings, sizeof (char *));
	//arr_strings (arr_ptr_strings, buf_elements, n_elem);
	
	filling_struct (ptr, buf_elements, n_elem);
	printf("lol\n");
	//qsort (arr_ptr_strings, n_strings, sizeof(char *), alphabetcomp);
	qsort (&(array[0].p), n_strings, sizeof(char *), alphabetcomp);
	printf("lollol\n");
    //проверим, что лежит в массиве arr_ptr_strings
//	for (int i = 0; i < n_strings; i++)
//	{
//		puts(*arr_ptr_strings);
//		arr_ptr_strings++;
//	}
	print_array_in_file (ptr, n_strings, file_output);
	
	return 0;
}
 
void filling_struct (struct str_ing * mass_1, char * buf, int n_elem_1)
{
	mass_1[0].p = buf;
	printf("mass_1[0].p = buf + 1 = %s\n", mass_1[0].p);
	for (int num_sym = 0, j = 0; num_sym < n_elem_1 && *buf != EOF; num_sym++)
	{
		(mass_1[j].lenght_str)++;
		if (*buf == '\0')
		{
			mass_1[j+1].p = buf + 1;
			//(mass_1[j].lenght_str)++;
			printf("mass_1[%d+1].p = buf + 1 = %s\n", j, mass_1[j+1].p);
			printf("mass_1[%d].lenght_str = %d\n", j, mass_1[j].lenght_str); //длина строки
			j++;
		}
		buf++;
	}
}

//void arr_strings (char ** mass, char * buf, int n_elem_1) // int n_strings_1 - кажется, что достаточно проверки конца buf
//{
//	*mass = buf;
//	printf("*mass = buf = %s\n", *mass);
//	mass++;
//	for (int i = 0; i < n_elem_1 && *buf != EOF; i++)
//	{
//		if (*buf == '\0')
//		{
//			*mass = buf + 1;
//			printf("*mass = buf = %s\n", *mass);
//			mass++;
//		}
//		buf++;
//	}
//}
 
int reading_file (char ** buf_elements_1, FILE ** file_output_1, const char * arg_console_1, const char * arg_console_2)
{
	struct stat file_info;
	FILE * file_input = fopen (arg_console_1, "rb");
	if (file_input == NULL)
	{
		fprintf(stderr, "Error: unable to open argv file[1]\n");
		return -1;
	}
	
	*file_output_1 = fopen (arg_console_2, "wb");
	if (file_output_1 == NULL)
	{
		fprintf(stderr, "Error: unable to open argv file[2]\n");
		return -2;
	}
	
	stat (arg_console_1, &file_info);
	int n_elem = file_info.st_size;
	printf("n_elem = %d\n", n_elem);
	
	*buf_elements_1 = (char *) calloc (n_elem + 1, sizeof(char));
	if (*buf_elements_1 == NULL)
	{
		fprintf (stderr, "Error in allocating memory for saving.\n");
		return -2;
	}	
	(*buf_elements_1)[n_elem] = '\0';
	
	fread (*buf_elements_1, 1, n_elem, file_input);
	
	return n_elem;
}

int correct_buf (char * buf_elements_2, int n_elements)
{
	int n_strings = 0;
	
	printf("buf_elements_2 = %p\n", buf_elements_2);
	
	for (int i = 0; i < n_elements; i++)
	{
//		if (buf_elements_2[i] == '\r')
//			buf_elements_2[i] = '\0';
		if (buf_elements_2[i] == '\n')
		{
			//printf ("buf_elements_2[i] = %d\n", &(buf_elements_2[i]) - buf_elements_2);
			buf_elements_2[i] = '\0';
			n_strings++;
		}
	}
	return n_strings+1;
}

int alphabetcomp (const void * str1, const void * str2)
{
	return strcmp (*(char **) str1, *(char **) str2);	
}

int numcomp (const void * n1, const void * n2)
{
	if (*((int *)n1) > *((int *) n2))
		return 1;
	else if (*((int *)n1) < *((int *) n2))
		return -1;
	return 0;
}

void swap (const void * str1, const void * str2)
{
	const void * temp = nullptr;
	temp = str1; 
	str1 = str2;
	str2 = temp;
}

void print_array_in_file (struct str_ing * ptr_1, int n_string, FILE * file_output)
{
	printf("lol\n");
	for (int i = 0; i < n_string; i++)
	{
		printf("ptr_1[%d].p = %s\n", i, ptr_1[i].p);
		fputs(ptr_1[i].p, file_output);
	}
}

//int my_strcmp (const char * string1, const char * string2)
//{
//	for (int i = 0, j = 0; string1[i] != '\0' && string2[j] != '\0'; i++, j++)
//	{
//		if (!isalpha(string1[i]))
//			i++;
//		if (!isalpha(string2[j]))
//			j++;
//		if ((string1[i] > string2[i]) && isalpha(string1[i]))
//			return 1;
//		else if ((string1[i] < string2[i]) && isalpha(string1[i]))
//			return -1;
//		else 
//			continue;
//	}
//	return 0;
//}
